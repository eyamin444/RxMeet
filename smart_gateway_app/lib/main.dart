// lib/main.dart
import 'dart:async';

import 'package:flutter/foundation.dart' show kIsWeb, defaultTargetPlatform, TargetPlatform;
import 'package:flutter/material.dart';

import 'services/api.dart';
import 'services/auth.dart';
import 'models.dart';
import 'widgets/snack.dart';

import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:flutter_timezone/flutter_timezone.dart';
import 'package:timezone/timezone.dart' as tz;
import 'package:timezone/data/latest.dart' as tzdata;
import 'package:shared_preferences/shared_preferences.dart';

import 'app_config.dart';
import 'package:livekit_client/livekit_client.dart' as lk;

// GENERATED BY flutterfire configure
import 'firebase_options.dart';

// Aliases prevent naming clashes
import 'screens/admin/dashboard.dart' as admin show AdminDashboard;
import 'screens/doctor/dashboard.dart' as doctor show DoctorDashboard;
import 'screens/patient/dashboard.dart' as patient show PatientDashboard;

// Incoming call UI and ringtone service (separate files)
import 'screens/notifications/incoming_call.dart';
import 'services/ringtone.dart';

/// -----------------------
/// Searchable markers:
/// Use Ctrl+F with these tags:
///   - <<FCM_BACKGROUND_HANDLER>>
///   - <<INIT_NOTIFICATIONS>>
///   - <<FCM_TOKEN_REGISTER>>
///   - <<FCM_MESSAGE_HANDLERS>>
///   - <<RINGTONE_UNLOCK_PROMPT>>
/// -----------------------

final FlutterLocalNotificationsPlugin notifications = FlutterLocalNotificationsPlugin();

// Global navigator key so we can open incoming-call UI from background/handlers.
final GlobalKey<NavigatorState> navigatorKey = GlobalKey<NavigatorState>();

/// <<FCM_BACKGROUND_HANDLER>>
// Background handler must be a top-level function.
Future<void> _firebaseMessagingBackgroundHandler(RemoteMessage message) async {
  // Ensure Firebase is initialized in the background isolate.
  if (kIsWeb) {
    await Firebase.initializeApp(options: DefaultFirebaseOptions.currentPlatform);
  } else {
    await Firebase.initializeApp();
  }

  // Lightweight log for debugging.
  // Avoid heavy work here.
  print('FCM background: id=${message.messageId} data=${message.data}');
}

/// <<INIT_NOTIFICATIONS>>
Future<void> initNotifications() async {
  const androidInit = AndroidInitializationSettings('@mipmap/ic_launcher');
  // iOS initialization options can be added if needed.
  await notifications.initialize(const InitializationSettings(android: androidInit));

  // Timezone (kept to Asia/Dhaka as earlier)
  tzdata.initializeTimeZones();
  tz.setLocalLocation(tz.getLocation('Asia/Dhaka'));

  // Request permission for notifications on Android 13+ (and create channels)
  final androidImpl =
      notifications.resolvePlatformSpecificImplementation<AndroidFlutterLocalNotificationsPlugin>();
  await androidImpl?.requestNotificationsPermission();

  if (androidImpl != null) {
    try {
      await androidImpl.createNotificationChannel(const AndroidNotificationChannel(
        'default_channel',
        'General',
        description: 'General notifications',
        importance: Importance.defaultImportance,
      ));
      await androidImpl.createNotificationChannel(const AndroidNotificationChannel(
        'calls_channel',
        'Incoming Calls',
        description: 'Incoming call notifications',
        importance: Importance.max,
      ));
    } catch (e) {
      print('createNotificationChannel error: $e');
    }
  }
}

/// Helper to show a local notification. For call notifications sets fullScreenIntent on Android.
Future<void> _showLocalNotification(RemoteMessage message, {bool isCall = false}) async {
  final data = message.data;
  final title = message.notification?.title ?? data['title'] ?? (isCall ? 'Incoming call' : 'Notification');
  final body = message.notification?.body ?? data['body'] ?? '';

  final androidDetails = AndroidNotificationDetails(
    isCall ? 'calls_channel' : 'default_channel',
    isCall ? 'Incoming Calls' : 'General',
    channelDescription: isCall ? 'Incoming call notifications' : 'General notifications',
    importance: isCall ? Importance.max : Importance.high,
    priority: isCall ? Priority.high : Priority.high,
    playSound: true,
    fullScreenIntent: isCall,
    category: isCall ? AndroidNotificationCategory.call : AndroidNotificationCategory.message,
  );

  final details = NotificationDetails(android: androidDetails);
  final id = DateTime.now().microsecond;
  await notifications.show(id, title, body, details, payload: data.isNotEmpty ? data.toString() : null);
}

Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();

  // Initialize Firebase (web uses options; mobile will use default)
  await Firebase.initializeApp(options: DefaultFirebaseOptions.currentPlatform);

  // Background message handler registration
  FirebaseMessaging.onBackgroundMessage(_firebaseMessagingBackgroundHandler);

  // Initialize LiveKit + notifications + ringtone service + API
  await lk.LiveKitClient.initialize();
  await initNotifications();
  await RingtoneService.init();
  await Api.init(override: AppConfig.apiBaseUrl);

  runApp(const SmartGatewayApp());
}

/// The App root
class SmartGatewayApp extends StatelessWidget {
  const SmartGatewayApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      navigatorKey: navigatorKey,
      title: 'RxMeet',
      debugShowCheckedModeBanner: false,
      theme: ThemeData(
        useMaterial3: true,
        colorSchemeSeed: Colors.teal,
        typography: Typography.material2021(),
      ),
      home: const _Bootstrap(),
    );
  }
}

/// Bootstrap widget: loads current user and registers FCM for patient only.
class _Bootstrap extends StatefulWidget {
  const _Bootstrap();

  @override
  State<_Bootstrap> createState() => _BootstrapState();
}

class _BootstrapState extends State<_Bootstrap> {
  User? me;
  bool loading = true;

  @override
  void initState() {
    super.initState();
    _bootstrap();
  }

  Future<void> _bootstrap() async {
    try {
      me = await AuthService.whoAmI();
    } catch (_) {
      me = null;
    }

    // If logged-in patient, show ringtone unlock prompt once (web)
    if (me != null && me!.role == 'patient') {
      // Prompt the user in web to allow audio (we do not auto-play).
      final prefs = await SharedPreferences.getInstance();
      final unlocked = prefs.getBool('ringtone_unlocked') ?? false;
      if (!unlocked) {
        // call after frame so app is ready
        WidgetsBinding.instance.addPostFrameCallback((_) => _showEnableRingtoneDialog());
      }
    }

    // <<FCM_TOKEN_REGISTER>>
    // Register FCM token and message handlers ONLY for patients.
    if (me != null && me!.role == 'patient') {
      // Android 13+ runtime notification permission
      if (!kIsWeb && defaultTargetPlatform == TargetPlatform.android) {
        try {
          var status = await Permission.notification.status;
          if (status.isDenied || status.isLimited || status.isPermanentlyDenied) {
            await Permission.notification.request();
          }
        } catch (e) {
          print('Permission.request error: $e');
        }
      } else if (!kIsWeb && defaultTargetPlatform == TargetPlatform.iOS) {
        // iOS request
        await FirebaseMessaging.instance.requestPermission(alert: true, badge: true, sound: true);
      } else if (kIsWeb) {
        // For web, nothing automatic; token can still require vapidKey depending on configuration.
      }

      // Get token (try plain, and fallback with vapidKey if web requires it)
      try {
        String? token;
        try {
          token = await FirebaseMessaging.instance.getToken();
        } catch (e) {
          // fallback: some web setups require vapidKey
          try {
            final webOpts = DefaultFirebaseOptions.web;
            final dynamic maybeVapid = webOpts != null ? (webOpts as dynamic).vapidKey : null;
            if (kIsWeb && maybeVapid != null) {
              token = await FirebaseMessaging.instance.getToken(vapidKey: maybeVapid as String);
            }
          } catch (_) {
            // ignore
          }
        }

        if (token != null && token.isNotEmpty) {
          await Api.post('/me/device_token', data: {'token': token, 'platform': kIsWeb ? 'web' : 'android'});
          print('FCM token sent to server: $token');
        } else {
          print('FCM getToken returned null/empty');
        }
      } catch (e) {
        print('Failed to obtain/send FCM token: $e');
      }

      // Listen for token refresh
      FirebaseMessaging.instance.onTokenRefresh.listen((newToken) async {
        try {
          await Api.post('/me/device_token', data: {'token': newToken});
          print('FCM refreshed token sent: $newToken');
        } catch (e) {
          print('Failed to send refreshed FCM token: $e');
        }
      });

      // <<FCM_MESSAGE_HANDLERS>>
      // Foreground messages: open IncomingCallPage on doctor_call (which plays ringtone).
      FirebaseMessaging.onMessage.listen((RemoteMessage message) {
        final data = message.data;
        final isCall = (data['type'] == 'doctor_call');
        print('FCM onMessage: ${data} notification=${message.notification}');
        if (isCall) {
          final apptId = int.tryParse(data['appointment_id'] ?? '') ?? 0;
          final room = data['room'] ?? '';
          final doctorName = data['doctor_name'] ?? 'Doctor';
          final callLogId = data.containsKey('call_log_id') ? int.tryParse(data['call_log_id'] ?? '') : null;

          // Push incoming call page (IncomingCallPage will play ringtone in initState)
          navigatorKey.currentState?.push(MaterialPageRoute(
            builder: (_) => IncomingCallPage(
              appointmentId: apptId,
              room: room,
              doctorName: doctorName,
              callLogId: callLogId,
            ),
          ));
        } else {
          _showLocalNotification(message, isCall: false);
        }
      });

      // When user taps notification and app opens
      FirebaseMessaging.onMessageOpenedApp.listen((RemoteMessage message) {
        final data = message.data;
        print('FCM onMessageOpenedApp: ${data}');
        if (data['type'] == 'doctor_call') {
          final apptId = int.tryParse(data['appointment_id'] ?? '') ?? 0;
          final room = data['room'] ?? '';
          final doctorName = data['doctor_name'] ?? 'Doctor';
          final callLogId = data.containsKey('call_log_id') ? int.tryParse(data['call_log_id'] ?? '') : null;

          navigatorKey.currentState?.push(MaterialPageRoute(
            builder: (_) => IncomingCallPage(
              appointmentId: apptId,
              room: room,
              doctorName: doctorName,
              callLogId: callLogId,
            ),
          ));
        } else {
          // Open normal notification target (optional)
          _showLocalNotification(message, isCall: false);
        }
      });

      // App launched from terminated state via a notification
      final initialMessage = await FirebaseMessaging.instance.getInitialMessage();
      if (initialMessage != null && initialMessage.data['type'] == 'doctor_call') {
        final data = initialMessage.data;
        final apptId = int.tryParse(data['appointment_id'] ?? '') ?? 0;
        final room = data['room'] ?? '';
        final doctorName = data['doctor_name'] ?? 'Doctor';
        final callLogId = data.containsKey('call_log_id') ? int.tryParse(data['call_log_id'] ?? '') : null;

        WidgetsBinding.instance.addPostFrameCallback((_) {
          navigatorKey.currentState?.push(MaterialPageRoute(
            builder: (_) => IncomingCallPage(
              appointmentId: apptId,
              room: room,
              doctorName: doctorName,
              callLogId: callLogId,
            ),
          ));
        });
      }
    } // end if patient

    if (mounted) setState(() => loading = false);
  }

  /// <<RINGTONE_UNLOCK_PROMPT>>
  /// This dialog is shown to web patients once to allow autoplay (tiny unlock play).
  Future<void> _showEnableRingtoneDialog() async {
    final ctx = navigatorKey.currentContext;
    if (ctx == null) return;
    showDialog(
      context: ctx,
      barrierDismissible: false,
      builder: (ctx2) {
        return AlertDialog(
          title: const Text('Enable Ringtone'),
          content: const Text('To hear incoming call ringtone in the browser, please enable ringtone (allow audio).'),
          actions: [
            TextButton(
              onPressed: () {
                Navigator.of(ctx2).pop();
              },
              child: const Text('Later'),
            ),
            ElevatedButton(
              onPressed: () async {
                Navigator.of(ctx2).pop();
                await RingtoneService.unlockAudioOnce();
                final prefs = await SharedPreferences.getInstance();
                await prefs.setBool('ringtone_unlocked', true);
                if (mounted) setState(() {});
                showSnack(navigatorKey.currentContext!, 'Ringtone enabled');
              },
              child: const Text('Enable Ringtone'),
            ),
          ],
        );
      },
    );
  }

  @override
  Widget build(BuildContext context) {
    if (loading) return const Scaffold(body: Center(child: CircularProgressIndicator()));
    if (me == null) return const LoginPage();
    return HomeRouter(me: me!);
  }
}

/// Router that returns the correct dashboard depending on role
class HomeRouter extends StatelessWidget {
  const HomeRouter({super.key, required this.me});
  final User me;

  @override
  Widget build(BuildContext context) {
    switch (me.role) {
      case 'admin':
        return admin.AdminDashboard(me: me);
      case 'doctor':
        return doctor.DoctorDashboard(me: me);
      default:
        return patient.PatientDashboard(me: me);
    }
  }
}

/// =====================
/// LOGIN + REGISTER PAGE
/// (unchanged UI from your earlier code)
/// =====================
class LoginPage extends StatefulWidget {
  const LoginPage({super.key});
  @override
  State<LoginPage> createState() => _LoginPageState();
}

class _LoginPageState extends State<LoginPage> {
  final email = TextEditingController();
  final pass = TextEditingController();
  bool busy = false;

  void _prefill(String role) {
    if (role == 'patient') {
      email.text = 'patient1@test.com';
      pass.text = 'patientpass';
    } else if (role == 'doctor') {
      email.text = 'alice@clinic.tes';
      pass.text = 'alicepass';
    } else if (role == 'admin') {
      email.text = 'admin@example.com';
      pass.text = 'admin';
    }
  }

  Future<void> _login() async {
    setState(() => busy = true);
    try {
      await AuthService.login(email.text.trim(), pass.text);
      final me = await AuthService.whoAmI();
      if (context.mounted) {
        Navigator.of(context).pushReplacement(MaterialPageRoute(builder: (_) => HomeRouter(me: me)));
      }
    } catch (e) {
      if (context.mounted) showSnack(context, 'Login failed: $e');
    } finally {
      if (mounted) setState(() => busy = false);
    }
  }

  Future<void> _ping() async {
    try {
      final pong = await Api.get('/ping');
      if (mounted) showSnack(context, 'API OK: $pong @ ${Api.baseUrl}');
    } catch (e) {
      if (mounted) showSnack(context, 'API NOT REACHABLE @ ${Api.baseUrl}\n$e');
    }
  }

  @override
  Widget build(BuildContext context) {
    final double w = MediaQuery.of(context).size.width.clamp(320.0, 520.0).toDouble();
    return Scaffold(
      appBar: AppBar(title: const Text('Smart Gateway — Login')),
      body: Center(
        child: ConstrainedBox(
          constraints: BoxConstraints(maxWidth: w),
          child: Card(
            margin: const EdgeInsets.all(16),
            child: Padding(
              padding: const EdgeInsets.all(16),
              child: Column(mainAxisSize: MainAxisSize.min, children: [
                Text('API: ${Api.baseUrl}', style: Theme.of(context).textTheme.bodySmall),
                const SizedBox(height: 6),
                FilledButton.icon(onPressed: _ping, icon: const Icon(Icons.wifi_tethering), label: const Text('Ping API')),
                const Divider(height: 24),
                TextField(controller: email, decoration: const InputDecoration(labelText: 'Email or Phone', border: OutlineInputBorder())),
                const SizedBox(height: 12),
                TextField(controller: pass, obscureText: true, decoration: const InputDecoration(labelText: 'Password', border: OutlineInputBorder())),
                const SizedBox(height: 12),
                Row(
                  children: [
                    Expanded(child: OutlinedButton(onPressed: () => _prefill('admin'), child: const Text('Fill Admin'))),
                    const SizedBox(width: 8),
                    Expanded(child: OutlinedButton(onPressed: () => _prefill('doctor'), child: const Text('Fill Doctor'))),
                    const SizedBox(width: 8),
                    Expanded(child: OutlinedButton(onPressed: () => _prefill('patient'), child: const Text('Fill Patient'))),
                  ],
                ),
                const SizedBox(height: 12),
                FilledButton(
                  onPressed: busy ? null : _login,
                  child: busy ? const SizedBox(width: 18, height: 18, child: CircularProgressIndicator(strokeWidth: 2)) : const Text('Login'),
                ),
                const SizedBox(height: 8),
                TextButton(onPressed: () => Navigator.of(context).push(MaterialPageRoute(builder: (_) => const RegisterPage())), child: const Text('Register as Patient')),
              ]),
            ),
          ),
        ),
      ),
    );
  }
}

class RegisterPage extends StatefulWidget {
  const RegisterPage({super.key});
  @override
  State<RegisterPage> createState() => _RegisterPageState();
}

class _RegisterPageState extends State<RegisterPage> {
  final name = TextEditingController();
  final email = TextEditingController();
  final phone = TextEditingController();
  final pass = TextEditingController();
  bool busy = false;

  Future<void> _register() async {
    setState(() => busy = true);
    try {
      await AuthService.registerPatient(
        name: name.text,
        email: email.text.isEmpty ? null : email.text,
        phone: phone.text.isEmpty ? null : phone.text,
        password: pass.text,
      );
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Registered! Now login.')));
        Navigator.pop(context);
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Register failed: $e')));
      }
    } finally {
      if (mounted) setState(() => busy = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    final double w = MediaQuery.of(context).size.width.clamp(320.0, 520.0).toDouble();
    return Scaffold(
      appBar: AppBar(title: const Text('Register (Patient)')),
      body: Center(
        child: ConstrainedBox(
          constraints: BoxConstraints(maxWidth: w),
          child: Card(
            child: Padding(
              padding: const EdgeInsets.all(16),
              child: Column(mainAxisSize: MainAxisSize.min, children: [
                TextField(controller: name, decoration: const InputDecoration(labelText: 'Name', border: OutlineInputBorder())),
                const SizedBox(height: 12),
                TextField(controller: email, decoration: const InputDecoration(labelText: 'Email (optional)', border: OutlineInputBorder())),
                const SizedBox(height: 12),
                TextField(controller: phone, decoration: const InputDecoration(labelText: 'Phone (optional)', border: OutlineInputBorder())),
                const SizedBox(height: 12),
                TextField(controller: pass, obscureText: true, decoration: const InputDecoration(labelText: 'Password', border: OutlineInputBorder())),
                const SizedBox(height: 12),
                FilledButton(onPressed: busy ? null : _register, child: busy ? const SizedBox(width: 18, height: 18, child: CircularProgressIndicator(strokeWidth: 2)) : const Text('Create account')),
              ]),
            ),
          ),
        ),
      ),
    );
  }
}

/// Minimal AppointmentDetailPage used for notification navigation.
/// Replace with your own detailed page if you already have it.
class AppointmentDetailPage extends StatefulWidget {
  final int apptId;
  const AppointmentDetailPage({super.key, required this.apptId});
  @override
  State<AppointmentDetailPage> createState() => _AppointmentDetailPageState();
}

class _AppointmentDetailPageState extends State<AppointmentDetailPage> {
  Map<String, dynamic>? appt;
  bool loading = true;
  String err = '';

  @override
  void initState() {
    super.initState();
    _load();
  }

  Future<void> _load() async {
    setState(() => loading = true);
    try {
      final res = await Api.get('/appointments/${widget.apptId}');
      appt = (res is Map) ? Map<String, dynamic>.from(res as Map) : null;
      err = '';
    } catch (e) {
      err = 'Load failed: $e';
    } finally {
      if (mounted) setState(() => loading = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    if (loading) return const Scaffold(body: Center(child: CircularProgressIndicator()));
    if (err.isNotEmpty) return Scaffold(appBar: AppBar(title: const Text('Appointment')), body: Center(child: Text(err)));
    final d = appt ?? {};
    final doctor = (d['doctor'] is Map) ? d['doctor'] : null;
    final doctorName = doctor != null ? (doctor['name'] ?? '') : (d['doctor_name'] ?? '');
    final time = d['time'] ?? d['slot'] ?? '—';
    final status = d['progress'] ?? d['status'] ?? '—';

    return Scaffold(
      appBar: AppBar(title: const Text('Appointment')),
      body: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(crossAxisAlignment: CrossAxisAlignment.start, children: [
          Text('Appointment ID: ${d['id'] ?? widget.apptId}', style: const TextStyle(fontWeight: FontWeight.w600)),
          const SizedBox(height: 8),
          Text('Doctor: $doctorName'),
          const SizedBox(height: 8),
          Text('Time: $time'),
          const SizedBox(height: 8),
          Text('Status: $status'),
          const SizedBox(height: 20),
          ElevatedButton(
            onPressed: () {
              showSnack(context, 'Join video not implemented in this minimal detail page');
            },
            child: const Text('Join Video'),
          ),
        ]),
      ),
    );
  }
}
