// lib/main.dart
// Full file - paste to replace existing lib/main.dart

import 'dart:async';
import 'dart:convert';

import 'package:flutter/foundation.dart' show kIsWeb, defaultTargetPlatform, TargetPlatform;
import 'package:flutter/material.dart';

import 'services/api.dart';
import 'services/auth.dart';
import 'models.dart';
import 'widgets/snack.dart';
import 'services/notification_center.dart';

import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:flutter_timezone/flutter_timezone.dart';
import 'package:timezone/timezone.dart' as tz;
import 'package:timezone/data/latest.dart' as tzdata;
import 'package:shared_preferences/shared_preferences.dart';

import 'app_config.dart';
import 'package:livekit_client/livekit_client.dart' as lk;

// GENERATED BY flutterfire configure
import 'firebase_options.dart';

// Aliases prevent naming clashes
import 'screens/admin/dashboard.dart' as admin show AdminDashboard;
import 'screens/doctor/dashboard.dart' as doctor show DoctorDashboard;
import 'screens/patient/dashboard.dart' as patient show PatientDashboard;
import 'screens/chat/chat_screen.dart';


// Incoming call UI and ringtone service (separate files)
import 'screens/notifications/incoming_call.dart';
import 'services/ringtone.dart';

/// -----------------------
/// Use Ctrl+F with these tags:
///   - <<FCM_BACKGROUND_HANDLER>>
///   - <<INIT_NOTIFICATIONS>>
///   - <<FCM_TOKEN_REGISTER>>
///   - <<FCM_MESSAGE_HANDLERS>>
///   - <<RINGTONE_UNLOCK_PROMPT>>
/// -----------------------

final FlutterLocalNotificationsPlugin notifications = FlutterLocalNotificationsPlugin();

// Global navigator key so we can open incoming-call UI from background/handlers.
final GlobalKey<NavigatorState> navigatorKey = GlobalKey<NavigatorState>();

// Persisted dedupe key in SharedPreferences
const String _kSeenMsgsKey = 'seen_message_ids';

// Keep a small in-memory set of seen message ids to avoid double-notifying
final Set<String> _seenMessageIds = <String>{};

/// Load seen IDs from SharedPreferences into _seenMessageIds.
Future<void> _loadSeenMessageIds() async {
  try {
    final prefs = await SharedPreferences.getInstance();
    final list = prefs.getStringList(_kSeenMsgsKey) ?? <String>[];
    _seenMessageIds
      ..clear()
      ..addAll(list);
    print('Loaded ${_seenMessageIds.length} seen message ids');
  } catch (e) {
    print('_loadSeenMessageIds error: $e');
  }
}

/// Save a single message id into persistence and the in-memory set.
Future<void> _saveSeenMessageId(String mid) async {
  try {
    if (mid.isEmpty) return;
    _seenMessageIds.add(mid);
    final prefs = await SharedPreferences.getInstance();
    await prefs.setStringList(_kSeenMsgsKey, _seenMessageIds.toList());
  } catch (e) {
    print('_saveSeenMessageId error: $e');
  }
}

/// Returns true if the message should be processed (i.e., NOT duplicate);
/// If it is new we mark it persisted so subsequent deliveries are ignored.
Future<bool> _shouldProcessMessage(RemoteMessage message) async {
  try {
    final mid = (message.data['message_id'] ?? message.messageId)?.toString() ?? '';
    if (mid.isEmpty) return true; // can't dedupe without an id
    // in-memory quick check
    if (_seenMessageIds.contains(mid)) {
      print('Duplicate message suppressed (in-memory): $mid');
      return false;
    }
    // persist it
    await _saveSeenMessageId(mid);
    return true;
  } catch (e) {
    print('_shouldProcessMessage error: $e');
    return true;
  }
}

// <<FCM_BACKGROUND_HANDLER>>
// Background handler must be a top-level function and reachable by the platform.
// Use vm:entry-point to avoid tree-shaking in release builds.
@pragma('vm:entry-point')
Future<void> _firebaseMessagingBackgroundHandler(RemoteMessage message) async {
  // Initialize Flutter & Firebase in background isolate
  WidgetsFlutterBinding.ensureInitialized();
  if (kIsWeb) {
    await Firebase.initializeApp(options: DefaultFirebaseOptions.currentPlatform);
  } else {
    await Firebase.initializeApp();
  }

  // Initialize notifications in background (safe, idempotent)
  try {
    await initNotifications();
  } catch (e) {
    print('Background initNotifications error: $e');
  }

  // Lightweight log for debugging.
  print('FCM background: id=${message.messageId} data=${message.data}');

  // Background dedupe must use SharedPreferences directly because this is a separate isolate.
  try {
    final String mid = (message.data['message_id'] ?? message.messageId)?.toString() ??
        '${message.data['type'] ?? ''}_${message.data['appointment_id'] ?? ''}_${message.data['call_log_id'] ?? ''}_${message.data['room'] ?? ''}';
    if (mid.isNotEmpty) {
      try {
        final prefs = await SharedPreferences.getInstance();
        final seen = prefs.getStringList(_kSeenMsgsKey) ?? <String>[];
        if (seen.contains(mid)) {
          print('Background handler: duplicate message (ignored): $mid');
          return;
        }
        seen.add(mid);
        await prefs.setStringList(_kSeenMsgsKey, seen);
      } catch (e) {
        print('Background handler prefs dedupe error: $e');
      }
    }
  } catch (e) {
    print('Background dedupe failure: $e');
  }

  // If this is a call notification, show a full-screen local notification so the
  // system can present the incoming-call UI (and play sound) even when app is backgrounded.
  try {
    final data = message.data;
    final type = (data['type'] ?? '').toString();

    if (type == 'doctor_call' || type == 'video_ready') {
      // Show a full-screen incoming call notification (with native ringtone)
      await _showLocalNotification(message, isCall: true);
    } else {
      // Non-call: show normal notification
      await _showLocalNotification(message, isCall: false);
    }
  } catch (e) {
    print('Background handler show notification error: $e');
  }
}

// <<INIT_NOTIFICATIONS>>
Future<void> initNotifications() async {
  const androidInit = AndroidInitializationSettings('@mipmap/ic_launcher');
  // iOS initialization options can be added if needed.
  await notifications.initialize(const InitializationSettings(android: androidInit));

  // Timezone (kept to Asia/Dhaka as earlier)
  tzdata.initializeTimeZones();
  tz.setLocalLocation(tz.getLocation('Asia/Dhaka'));

  // Request permission for notifications on Android 13+ (and create channels)
  final androidImpl =
      notifications.resolvePlatformSpecificImplementation<AndroidFlutterLocalNotificationsPlugin>();
  await androidImpl?.requestNotificationsPermission();

  if (androidImpl != null) {
    try {
      await androidImpl.createNotificationChannel(const AndroidNotificationChannel(
        'default_channel',
        'General',
        description: 'General notifications',
        importance: Importance.defaultImportance,
      ));

      // Calls channel with custom native sound
      final callsChannel = AndroidNotificationChannel(
        'calls_channel',
        'Incoming Calls',
        description: 'Incoming call notifications',
        importance: Importance.max,
        sound: RawResourceAndroidNotificationSound('telehealth_incoming_ringtone'),
        playSound: true,
      );
      await androidImpl.createNotificationChannel(callsChannel);
    } catch (e) {
      print('createNotificationChannel error: $e');
    }
  }
}

Future<void> _showLocalNotification(RemoteMessage message, {bool isCall = false}) async {
  final data = message.data;
  final title = message.notification?.title ?? data['title'] ?? (isCall ? 'Incoming call' : 'Notification');
  final body = message.notification?.body ?? data['body'] ?? '';

  // dedupe by message id or a fallback key (protect local notifications too)
  final mid = (message.data['message_id'] ?? message.messageId)?.toString() ??
      '${data['type'] ?? ''}_${data['appointment_id'] ?? ''}_${data['call_log_id'] ?? ''}_${data['room'] ?? ''}';
  if (mid.isNotEmpty && _seenMessageIds.contains(mid)) {
    // already handled in this runtime (background handler persistence already added it)
    return;
  }
  // mark it so we don't show duplicates across runtime
  if (mid.isNotEmpty) await _saveSeenMessageId(mid);

  final androidDetails = AndroidNotificationDetails(
    isCall ? 'calls_channel' : 'default_channel',
    isCall ? 'Incoming Calls' : 'General',
    channelDescription: isCall ? 'Incoming call notifications' : 'General notifications',
    importance: isCall ? Importance.max : Importance.high,
    priority: isCall ? Priority.high : Priority.high,
    playSound: true,
    fullScreenIntent: isCall,
    category: isCall ? AndroidNotificationCategory.call : AndroidNotificationCategory.message,
    // Use the native ringtone resource for calls (calls_channel must be created with the resource)
    sound: isCall ? const RawResourceAndroidNotificationSound('telehealth_incoming_ringtone') : null,
    visibility: NotificationVisibility.public,
  );

  final details = NotificationDetails(android: androidDetails);
  final id = DateTime.now().microsecond;
  final payload = jsonEncode(data);
  await notifications.show(id, title, body, details, payload: payload);
}

Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();

  // Initialize Firebase (web uses options; mobile will use default)
  await Firebase.initializeApp(options: DefaultFirebaseOptions.currentPlatform);

  // Background message handler registration
  FirebaseMessaging.onBackgroundMessage(_firebaseMessagingBackgroundHandler);

  // Initialize LiveKit + notifications + ringtone service + API
  await lk.LiveKitClient.initialize();
  await initNotifications();
  await RingtoneService.init();
  await Api.init(override: AppConfig.apiBaseUrl);

  runApp(const SmartGatewayApp());
}

/// The App root
class SmartGatewayApp extends StatelessWidget {
  const SmartGatewayApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      navigatorKey: navigatorKey,
      title: 'RxMeet',
      debugShowCheckedModeBanner: false,
      theme: ThemeData(
        useMaterial3: true,
        colorSchemeSeed: Colors.teal,
        typography: Typography.material2021(),
      ),
      home: const _Bootstrap(),
    );
  }
}

/// Bootstrap widget: loads current user and registers FCM for patient only.
class _Bootstrap extends StatefulWidget {
  const _Bootstrap();

  @override
  State<_Bootstrap> createState() => _BootstrapState();
}

class _BootstrapState extends State<_Bootstrap> {
  User? me;
  bool loading = true;

  @override
  void initState() {
    super.initState();
    _bootstrap();
  }

  Future<void> _bootstrap() async {
    try {
      me = await AuthService.whoAmI();
    } catch (_) {
      me = null;
    }

    // Load persisted seen message ids before registering handlers so dedupe is effective immediately
    await _loadSeenMessageIds();

    // If logged-in patient, show ringtone unlock prompt once (web)
    if (me != null && me!.role == 'patient') {
      final prefs = await SharedPreferences.getInstance();
      final unlocked = prefs.getBool('ringtone_unlocked') ?? false;
      if (!unlocked) {
        // call after frame so app is ready
        WidgetsBinding.instance.addPostFrameCallback((_) => _showEnableRingtoneDialog());
      }
    }

    // <<FCM_TOKEN_REGISTER>>
    // Register FCM token and message handlers ONLY for patients.
    if (me != null && me!.role == 'patient') {
      // Android 13+ runtime notification permission
      if (!kIsWeb && defaultTargetPlatform == TargetPlatform.android) {
        try {
          var status = await Permission.notification.status;
          if (status.isDenied || status.isLimited || status.isPermanentlyDenied) {
            await Permission.notification.request();
          }
        } catch (e) {
          print('Permission.request error: $e');
        }
      } else if (!kIsWeb && defaultTargetPlatform == TargetPlatform.iOS) {
        // iOS request
        await FirebaseMessaging.instance.requestPermission(alert: true, badge: true, sound: true);
      } else if (kIsWeb) {
        // For web, nothing automatic; token can still require vapidKey depending on configuration.
      }

      // Get token (try plain, and fallback with vapidKey if web requires it)
      try {
        String? token;
        try {
          token = await FirebaseMessaging.instance.getToken();
        } catch (e) {
          // fallback: some web setups require vapidKey
          try {
            final webOpts = DefaultFirebaseOptions.web;
            final dynamic maybeVapid = webOpts != null ? (webOpts as dynamic).vapidKey : null;
            if (kIsWeb && maybeVapid != null) {
              token = await FirebaseMessaging.instance.getToken(vapidKey: maybeVapid as String);
            }
          } catch (_) {
            // ignore
          }
        }

        if (token != null && token.isNotEmpty) {
          await Api.post('/me/device_token', data: {'token': token, 'platform': kIsWeb ? 'web' : 'android'});
          print('FCM token sent to server: $token');
        } else {
          print('FCM getToken returned null/empty');
        }
      } catch (e) {
        print('Failed to obtain/send FCM token: $e');
      }

      // Listen for token refresh
      FirebaseMessaging.instance.onTokenRefresh.listen((newToken) async {
        try {
          await Api.post('/me/device_token', data: {'token': newToken});
          print('FCM refreshed token sent: $newToken');
        } catch (e) {
          print('Failed to send refreshed FCM token: $e');
        }
      });

      // <<FCM_MESSAGE_HANDLERS>>
      // Foreground messages
      FirebaseMessaging.onMessage.listen((RemoteMessage message) async {
        try {
          final data = message.data;
          print('FCM onMessage: ${data} notification=${message.notification}');

          // Dedupe using persisted mechanism
          if (!await _shouldProcessMessage(message)) {
            return;
          }

          final type = (data['type'] ?? '').toString();

          if (type == 'doctor_call' || type == 'video_ready') {
            // Push into NotificationCenter and let NotificationCenter open IncomingCallPage (deduped).
            await NotificationCenter().push(
              title: message.notification?.title ?? data['doctor_name'] ?? 'Incoming call',
              body: message.notification?.body ?? 'Incoming call',
              type: type,
              appointmentId: int.tryParse(data['appointment_id'] ?? '') ?? 0,
              room: data['room'],
              callLogId: data.containsKey('call_log_id') ? int.tryParse(data['call_log_id'] ?? '') : null,
              alsoShowSystemToast: false, // avoid duplicate system toast when showing UI
            );
          } else if (type == 'call_end' || type == 'video_end' || type == 'missed_call') {
            // notify app that call ended — this will close incoming UI if open.
            await NotificationCenter().push(
              title: message.notification?.title ?? (type == 'missed_call' ? 'Missed call' : 'Call ended'),
              body: message.notification?.body ?? '',
              type: type,
              appointmentId: int.tryParse(data['appointment_id'] ?? '') ?? 0,
              alsoShowSystemToast: false,
            );
          } else if (type == 'participant_joined') {
            // inform doctor UI that participant joined (useful for doctor side)
            await NotificationCenter().push(
              title: message.notification?.title ?? 'Participant joined',
              body: message.notification?.body ?? 'Participant joined the call',
              type: type,
              appointmentId: int.tryParse(data['appointment_id'] ?? '') ?? 0,
              alsoShowSystemToast: false,
            );
          } else {
            // generic notification
            await _showLocalNotification(message, isCall: false);
          }
        } catch (e, st) {
          print('Error handling onMessage: $e\n$st');
        }
      });

      // When user taps notification and app opens from background
      FirebaseMessaging.onMessageOpenedApp.listen((RemoteMessage message) async {
        try {
          // Dedupe before responding to user tap
          if (!await _shouldProcessMessage(message)) {
            return;
          }

          final data = message.data;
          print('FCM onMessageOpenedApp: ${data}');
          final type = (data['type'] ?? '').toString();
          if (type == 'doctor_call' || type == 'video_ready') {
            final apptId = int.tryParse(data['appointment_id'] ?? '') ?? 0;
            navigatorKey.currentState?.push(MaterialPageRoute(
              builder: (_) => IncomingCallPage(
                appointmentId: apptId,
                room: data['room'] ?? '',
                doctorName: data['doctor_name'] ?? 'Doctor',
                callLogId: data.containsKey('call_log_id') ? int.tryParse(data['call_log_id'] ?? '') : null,
              ),
            ));
          } else {
            await _showLocalNotification(message, isCall: false);
          }
        } catch (e) {
          print('Error in onMessageOpenedApp handler: $e');
        }
      });

      // App launched from terminated state via a notification
      try {
        final initialMessage = await FirebaseMessaging.instance.getInitialMessage();
        if (initialMessage != null) {
          // Dedupe/guard initialMessage too
          if (await _shouldProcessMessage(initialMessage)) {
            if ((initialMessage.data['type'] ?? '') == 'doctor_call') {
              final data = initialMessage.data;
              final apptId = int.tryParse(data['appointment_id'] ?? '') ?? 0;
              WidgetsBinding.instance.addPostFrameCallback((_) {
                navigatorKey.currentState?.push(MaterialPageRoute(
                  builder: (_) => IncomingCallPage(
                    appointmentId: apptId,
                    room: data['room'] ?? '',
                    doctorName: data['doctor_name'] ?? 'Doctor',
                    callLogId: data.containsKey('call_log_id') ? int.tryParse(data['call_log_id'] ?? '') : null,
                  ),
                ));
              });
            } else {
              // Not a call; optionally show a notification
              await _showLocalNotification(initialMessage, isCall: false);
            }
          }
        }
      } catch (e) {
        print('Error handling initialMessage: $e');
      }
    } // end if patient

    if (mounted) setState(() => loading = false);
  } // end _bootstrap

  Future<void> _showEnableRingtoneDialog() async {
    final ctx = navigatorKey.currentContext;
    if (ctx == null) return;
    showDialog(
      context: ctx,
      barrierDismissible: false,
      builder: (ctx2) {
        return AlertDialog(
          title: const Text('Enable Ringtone'),
          content: const Text('To hear incoming call ringtone in the browser, please enable ringtone (allow audio).'),
          actions: [
            TextButton(
              onPressed: () {
                Navigator.of(ctx2).pop();
              },
              child: const Text('Later'),
            ),
            ElevatedButton(
              onPressed: () async {
                Navigator.of(ctx2).pop();
                await RingtoneService.unlockAudioOnce();
                final prefs = await SharedPreferences.getInstance();
                await prefs.setBool('ringtone_unlocked', true);
                if (mounted) setState(() {});
                showSnack(navigatorKey.currentContext!, 'Ringtone enabled');
              },
              child: const Text('Enable Ringtone'),
            ),
          ],
        );
      },
    );
  }

  @override
  Widget build(BuildContext context) {
    if (loading) return const Scaffold(body: Center(child: CircularProgressIndicator()));
    if (me == null) return const LoginPage();
    return HomeRouter(me: me!);
  }
}

/// Router that returns the correct dashboard depending on role
class HomeRouter extends StatelessWidget {
  const HomeRouter({super.key, required this.me});
  final User me;

  @override
  Widget build(BuildContext context) {
    switch (me.role) {
      case 'admin':
        return admin.AdminDashboard(me: me);
      case 'doctor':
        return doctor.DoctorDashboard(me: me);
      default:
        return patient.PatientDashboard(me: me);
    }
  }
}

/// =====================
/// LOGIN + REGISTER PAGE
/// (unchanged UI from your earlier code)
/// =====================
class LoginPage extends StatefulWidget {
  const LoginPage({super.key});
  @override
  State<LoginPage> createState() => _LoginPageState();
}

class _LoginPageState extends State<LoginPage> {
  final email = TextEditingController();
  final pass = TextEditingController();
  bool busy = false;

  void _prefill(String role) {
    if (role == 'patient') {
      email.text = 'patient1@test.com';
      pass.text = 'patientpass';
    } else if (role == 'doctor') {
      email.text = 'alice@clinic.tes';
      pass.text = 'alicepass';
    } else if (role == 'admin') {
      email.text = 'admin@example.com';
      pass.text = 'admin';
    }
  }

  Future<void> _login() async {
    setState(() => busy = true);
    try {
      await AuthService.login(email.text.trim(), pass.text);
      final me = await AuthService.whoAmI();
      if (context.mounted) {
        Navigator.of(context).pushReplacement(MaterialPageRoute(builder: (_) => HomeRouter(me: me)));
      }
    } catch (e) {
      if (context.mounted) showSnack(context, 'Login failed: $e');
    } finally {
      if (mounted) setState(() => busy = false);
    }
  }

  Future<void> _ping() async {
    try {
      final pong = await Api.get('/ping');
      if (mounted) showSnack(context, 'API OK: $pong @ ${Api.baseUrl}');
    } catch (e) {
      if (mounted) showSnack(context, 'API NOT REACHABLE @ ${Api.baseUrl}\n$e');
    }
  }

  @override
  Widget build(BuildContext context) {
    final double w = MediaQuery.of(context).size.width.clamp(320.0, 520.0).toDouble();
    return Scaffold(
      appBar: AppBar(title: const Text('Smart Gateway — Login')),
      body: Center(
        child: ConstrainedBox(
          constraints: BoxConstraints(maxWidth: w),
          child: Card(
            margin: const EdgeInsets.all(16),
            child: Padding(
              padding: const EdgeInsets.all(16),
              child: Column(mainAxisSize: MainAxisSize.min, children: [
                Text('API: ${Api.baseUrl}', style: Theme.of(context).textTheme.bodySmall),
                const SizedBox(height: 6),
                FilledButton.icon(onPressed: _ping, icon: const Icon(Icons.wifi_tethering), label: const Text('Ping API')),
                const Divider(height: 24),
                TextField(controller: email, decoration: const InputDecoration(labelText: 'Email or Phone', border: OutlineInputBorder())),
                const SizedBox(height: 12),
                TextField(controller: pass, obscureText: true, decoration: const InputDecoration(labelText: 'Password', border: OutlineInputBorder())),
                const SizedBox(height: 12),
                Row(
                  children: [
                    Expanded(child: OutlinedButton(onPressed: () => _prefill('admin'), child: const Text('Fill Admin'))),
                    const SizedBox(width: 8),
                    Expanded(child: OutlinedButton(onPressed: () => _prefill('doctor'), child: const Text('Fill Doctor'))),
                    const SizedBox(width: 8),
                    Expanded(child: OutlinedButton(onPressed: () => _prefill('patient'), child: const Text('Fill Patient'))),
                  ],
                ),
                const SizedBox(height: 12),
                FilledButton(
                  onPressed: busy ? null : _login,
                  child: busy ? const SizedBox(width: 18, height: 18, child: CircularProgressIndicator(strokeWidth: 2)) : const Text('Login'),
                ),
                const SizedBox(height: 8),
                TextButton(onPressed: () => Navigator.of(context).push(MaterialPageRoute(builder: (_) => const RegisterPage())), child: const Text('Register as Patient')),
              ]),
            ),
          ),
        ),
      ),
    );
  }
}

/// The rest of your RegisterPage, AppointmentDetailPage, etc., unchanged from your previous main.dart.
/// You can keep the same implementations you had for RegisterPage and AppointmentDetailPage.

class RegisterPage extends StatefulWidget {
  const RegisterPage({super.key});
  @override
  State<RegisterPage> createState() => _RegisterPageState();
}

class _RegisterPageState extends State<RegisterPage> {
  final name = TextEditingController();
  final email = TextEditingController();
  final phone = TextEditingController();
  final pass = TextEditingController();
  bool busy = false;

  Future<void> _register() async {
    setState(() => busy = true);
    try {
      await AuthService.registerPatient(
        name: name.text,
        email: email.text.isEmpty ? null : email.text,
        phone: phone.text.isEmpty ? null : phone.text,
        password: pass.text,
      );
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Registered! Now login.')));
        Navigator.pop(context);
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Register failed: $e')));
      }
    } finally {
      if (mounted) setState(() => busy = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    final double w = MediaQuery.of(context).size.width.clamp(320.0, 520.0).toDouble();
    return Scaffold(
      appBar: AppBar(title: const Text('Register (Patient)')),
      body: Center(
        child: ConstrainedBox(
          constraints: BoxConstraints(maxWidth: w),
          child: Card(
            child: Padding(
              padding: const EdgeInsets.all(16),
              child: Column(mainAxisSize: MainAxisSize.min, children: [
                TextField(controller: name, decoration: const InputDecoration(labelText: 'Name', border: OutlineInputBorder())),
                const SizedBox(height: 12),
                TextField(controller: email, decoration: const InputDecoration(labelText: 'Email (optional)', border: OutlineInputBorder())),
                const SizedBox(height: 12),
                TextField(controller: phone, decoration: const InputDecoration(labelText: 'Phone (optional)', border: OutlineInputBorder())),
                const SizedBox(height: 12),
                TextField(controller: pass, obscureText: true, decoration: const InputDecoration(labelText: 'Password', border: OutlineInputBorder())),
                const SizedBox(height: 12),
                FilledButton(onPressed: busy ? null : _register, child: busy ? const SizedBox(width: 18, height: 18, child: CircularProgressIndicator(strokeWidth: 2)) : const Text('Create account')),
              ]),
            ),
          ),
        ),
      ),
    );
  }
}

/// Minimal AppointmentDetailPage used for notification navigation.
/// Replace with your own detailed page if you already have it.
class AppointmentDetailPage extends StatefulWidget {
  final int apptId;
  const AppointmentDetailPage({super.key, required this.apptId});
  @override
  State<AppointmentDetailPage> createState() => _AppointmentDetailPageState();
}

class _AppointmentDetailPageState extends State<AppointmentDetailPage> {
  Map<String, dynamic>? appt;
  bool loading = true;
  String err = '';

  @override
  void initState() {
    super.initState();
    _load();
  }

  Future<void> _load() async {
    setState(() => loading = true);
    try {
      final res = await Api.get('/appointments/${widget.apptId}');
      appt = (res is Map) ? Map<String, dynamic>.from(res as Map) : null;
      err = '';
    } catch (e) {
      err = 'Load failed: $e';
    } finally {
      if (mounted) setState(() => loading = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    if (loading) return const Scaffold(body: Center(child: CircularProgressIndicator()));
    if (err.isNotEmpty) return Scaffold(appBar: AppBar(title: const Text('Appointment')), body: Center(child: Text(err)));
    final d = appt ?? {};
    final doctor = (d['doctor'] is Map) ? d['doctor'] : null;
    final doctorName = doctor != null ? (doctor['name'] ?? '') : (d['doctor_name'] ?? '');
    final time = d['time'] ?? d['slot'] ?? '—';
    final status = d['progress'] ?? d['status'] ?? '—';

    return Scaffold(
      appBar: AppBar(title: const Text('Appointment')),
      body: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(crossAxisAlignment: CrossAxisAlignment.start, children: [
          Text('Appointment ID: ${d['id'] ?? widget.apptId}', style: const TextStyle(fontWeight: FontWeight.w600)),
          const SizedBox(height: 8),
          Text('Doctor: $doctorName'),
          const SizedBox(height: 8),
          Text('Time: $time'),
          const SizedBox(height: 8),
          Text('Status: $status'),
          const SizedBox(height: 20),
          ElevatedButton(
            onPressed: () {
              showSnack(context, 'Join video not implemented in this minimal detail page');
            },
            child: const Text('Join Video'),
          ),
        ]),
      ),
    );
  }
}
