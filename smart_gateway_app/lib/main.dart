// lib/main.dart
import 'dart:async';
import 'dart:convert';


import 'package:flutter/foundation.dart' show kIsWeb, defaultTargetPlatform, TargetPlatform;
import 'package:flutter/material.dart';

import 'services/api.dart';
import 'services/auth.dart';
import 'models.dart';
import 'widgets/snack.dart';
import 'services/notification_center.dart';


import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:flutter_timezone/flutter_timezone.dart';
import 'package:timezone/timezone.dart' as tz;
import 'package:timezone/data/latest.dart' as tzdata;
import 'package:shared_preferences/shared_preferences.dart';

import 'app_config.dart';
import 'package:livekit_client/livekit_client.dart' as lk;

// GENERATED BY flutterfire configure
import 'firebase_options.dart';

// Aliases prevent naming clashes
import 'screens/admin/dashboard.dart' as admin show AdminDashboard;
import 'screens/doctor/dashboard.dart' as doctor show DoctorDashboard;
import 'screens/patient/dashboard.dart' as patient show PatientDashboard;

// Incoming call UI and ringtone service (separate files)
import 'screens/notifications/incoming_call.dart';
import 'services/ringtone.dart';

/// -----------------------
/// Searchable markers:
/// Use Ctrl+F with these tags:
///   - <<FCM_BACKGROUND_HANDLER>>
///   - <<INIT_NOTIFICATIONS>>
///   - <<FCM_TOKEN_REGISTER>>
///   - <<FCM_MESSAGE_HANDLERS>>
///   - <<RINGTONE_UNLOCK_PROMPT>>
/// -----------------------

final FlutterLocalNotificationsPlugin notifications = FlutterLocalNotificationsPlugin();

// Global navigator key so we can open incoming-call UI from background/handlers.
final GlobalKey<NavigatorState> navigatorKey = GlobalKey<NavigatorState>();

/// <<FCM_BACKGROUND_HANDLER>>
// Background handler must be a top-level function and reachable by the platform.
// Use vm:entry-point to avoid tree-shaking in release builds.
@pragma('vm:entry-point')
Future<void> _firebaseMessagingBackgroundHandler(RemoteMessage message) async {
  // Initialize Flutter & Firebase in background isolate
  WidgetsFlutterBinding.ensureInitialized();
  if (kIsWeb) {
    await Firebase.initializeApp(options: DefaultFirebaseOptions.currentPlatform);
  } else {
    await Firebase.initializeApp();
  }

  // Initialize notifications in background (safe, idempotent)
  try {
    await initNotifications();
  } catch (e) {
    print('Background initNotifications error: $e');
  }

  // Lightweight log for debugging.
  print('FCM background: id=${message.messageId} data=${message.data}');

  // If this is a call notification, show a full-screen local notification so the
  // system can present the incoming-call UI (and play sound) even when app is backgrounded.
  try {
    final data = message.data;
    final type = (data['type'] ?? '').toString();

    if (type == 'doctor_call' || type == 'video_ready') {
      // Show a full-screen incoming call notification (with native ringtone)
      await _showLocalNotification(message, isCall: true);
    } else {
      // Non-call: show normal notification
      await _showLocalNotification(message, isCall: false);
    }
  } catch (e) {
    print('Background handler show notification error: $e');
  }
}


/// <<INIT_NOTIFICATIONS>>
Future<void> initNotifications() async {
  const androidInit = AndroidInitializationSettings('@mipmap/ic_launcher');
  // iOS initialization options can be added if needed.
  await notifications.initialize(const InitializationSettings(android: androidInit));

  // Timezone (kept to Asia/Dhaka as earlier)
  tzdata.initializeTimeZones();
  tz.setLocalLocation(tz.getLocation('Asia/Dhaka'));

  // Request permission for notifications on Android 13+ (and create channels)

final androidImpl =
    notifications.resolvePlatformSpecificImplementation<AndroidFlutterLocalNotificationsPlugin>();
await androidImpl?.requestNotificationsPermission();

if (androidImpl != null) {
  try {
    await androidImpl.createNotificationChannel(const AndroidNotificationChannel(
      'default_channel',
      'General',
      description: 'General notifications',
      importance: Importance.defaultImportance,
    ));

    // Calls channel with custom native sound
    final callsChannel = AndroidNotificationChannel(
      'calls_channel',
      'Incoming Calls',
      description: 'Incoming call notifications',
      importance: Importance.max,
      sound: RawResourceAndroidNotificationSound('telehealth_incoming_ringtone'),
      playSound: true,
    );
    await androidImpl.createNotificationChannel(callsChannel);

  } catch (e) {
    print('createNotificationChannel error: $e');
  }
}

}

Future<void> _showLocalNotification(RemoteMessage message, {bool isCall = false}) async {
  final data = message.data;
  final title = message.notification?.title ?? data['title'] ?? (isCall ? 'Incoming call' : 'Notification');
  final body = message.notification?.body ?? data['body'] ?? '';

  final androidDetails = AndroidNotificationDetails(
    isCall ? 'calls_channel' : 'default_channel',
    isCall ? 'Incoming Calls' : 'General',
    channelDescription: isCall ? 'Incoming call notifications' : 'General notifications',
    importance: isCall ? Importance.max : Importance.high,
    priority: isCall ? Priority.high : Priority.high,
    playSound: true,
    fullScreenIntent: isCall,
    category: isCall ? AndroidNotificationCategory.call : AndroidNotificationCategory.message,
    // Use the native ringtone resource for calls (calls_channel must be created with the resource)
    sound: isCall ? const RawResourceAndroidNotificationSound('telehealth_incoming_ringtone') : null,
    visibility: NotificationVisibility.public,
  );

  final details = NotificationDetails(android: androidDetails);
  final id = DateTime.now().microsecond;

  // Use JSON payload so the UI can parse it reliably on tap/open
  final payload = jsonEncode(data);
  await notifications.show(id, title, body, details, payload: payload);
}


Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();

  // Initialize Firebase (web uses options; mobile will use default)
  await Firebase.initializeApp(options: DefaultFirebaseOptions.currentPlatform);

  // Background message handler registration
  FirebaseMessaging.onBackgroundMessage(_firebaseMessagingBackgroundHandler);

  // Initialize LiveKit + notifications + ringtone service + API
  await lk.LiveKitClient.initialize();
  await initNotifications();
  await RingtoneService.init();
  await Api.init(override: AppConfig.apiBaseUrl);

  runApp(const SmartGatewayApp());
}

/// The App root
class SmartGatewayApp extends StatelessWidget {
  const SmartGatewayApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      navigatorKey: navigatorKey,
      title: 'RxMeet',
      debugShowCheckedModeBanner: false,
      theme: ThemeData(
        useMaterial3: true,
        colorSchemeSeed: Colors.teal,
        typography: Typography.material2021(),
      ),
      home: const _Bootstrap(),
    );
  }
}

/// Bootstrap widget: loads current user and registers FCM for patient only.
class _Bootstrap extends StatefulWidget {
  const _Bootstrap();

  @override
  State<_Bootstrap> createState() => _BootstrapState();
}

class _BootstrapState extends State<_Bootstrap> {
  User? me;
  bool loading = true;

  @override
  void initState() {
    super.initState();
    _bootstrap();
  }

Future<void> _bootstrap() async {
  try {
    me = await AuthService.whoAmI();
  } catch (_) {
    me = null;
  }

  // If logged-in patient, show ringtone unlock prompt once (web)
  if (me != null && me!.role == 'patient') {
    final prefs = await SharedPreferences.getInstance();
    final unlocked = prefs.getBool('ringtone_unlocked') ?? false;
    if (!unlocked) {
      // call after frame so app is ready
      WidgetsBinding.instance.addPostFrameCallback((_) => _showEnableRingtoneDialog());
    }
  }

  // <<FCM_TOKEN_REGISTER>>
  // Register FCM token and message handlers ONLY for patients.
  if (me != null && me!.role == 'patient') {
    // Android 13+ runtime notification permission
    if (!kIsWeb && defaultTargetPlatform == TargetPlatform.android) {
      try {
        var status = await Permission.notification.status;
        if (status.isDenied || status.isLimited || status.isPermanentlyDenied) {
          await Permission.notification.request();
        }
      } catch (e) {
        print('Permission.request error: $e');
      }
    } else if (!kIsWeb && defaultTargetPlatform == TargetPlatform.iOS) {
      // iOS request
      await FirebaseMessaging.instance.requestPermission(alert: true, badge: true, sound: true);
    } else if (kIsWeb) {
      // For web, nothing automatic; token can still require vapidKey depending on configuration.
    }

    // Get token (try plain, and fallback with vapidKey if web requires it)
    try {
      String? token;
      try {
        token = await FirebaseMessaging.instance.getToken();
      } catch (e) {
        // fallback: some web setups require vapidKey
        try {
          final webOpts = DefaultFirebaseOptions.web;
          final dynamic maybeVapid = webOpts != null ? (webOpts as dynamic).vapidKey : null;
          if (kIsWeb && maybeVapid != null) {
            token = await FirebaseMessaging.instance.getToken(vapidKey: maybeVapid as String);
          }
        } catch (_) {
          // ignore
        }
      }

      if (token != null && token.isNotEmpty) {
        await Api.post('/me/device_token', data: {'token': token, 'platform': kIsWeb ? 'web' : 'android'});
        print('FCM token sent to server: $token');
      } else {
        print('FCM getToken returned null/empty');
      }
    } catch (e) {
      print('Failed to obtain/send FCM token: $e');
    }

    // Listen for token refresh
    FirebaseMessaging.instance.onTokenRefresh.listen((newToken) async {
      try {
        await Api.post('/me/device_token', data: {'token': newToken});
        print('FCM refreshed token sent: $newToken');
      } catch (e) {
        print('Failed to send refreshed FCM token: $e');
      }
    });

    // <<FCM_MESSAGE_HANDLERS>>
    // Foreground messages
    FirebaseMessaging.onMessage.listen((RemoteMessage message) async {
      try {
        final data = message.data;
        print('FCM onMessage: ${data} notification=${message.notification}');

        // If this is a doctor_call / video_ready, open IncomingCallPage only for patients
        // Use the 'me' we loaded above in _bootstrap().
        final isDoctor = me?.role == 'doctor';

        if (data['type'] == 'doctor_call' || data['type'] == 'video_ready') {
          if (!isDoctor) {
            // Show incoming call page for patient; IncomingCallPage will play ringtone in initState
            navigatorKey.currentState?.push(
              MaterialPageRoute(
                builder: (_) => IncomingCallPage(
                  appointmentId: int.tryParse(data['appointment_id'] ?? '') ?? 0,
                  room: data['room'] ?? '',
                  doctorName: data['doctor_name'] ?? '',
                  callLogId: data.containsKey('call_log_id')
                      ? int.tryParse(data['call_log_id'] ?? '')
                      : null,
                ),
              ),
            );
          } else {
            // For doctors, show a small local non-intrusive toast
            await NotificationCenter().push(
              title: 'Doctor is ready (local)',
              body: 'Call initiated — patient will be notified',
              type: 'info',
              appointmentId: int.tryParse(data['appointment_id'] ?? '') ?? 0,
              alsoShowSystemToast: true,
            );
          }
        } else {
          // Non-call notification: show local notification
          await _showLocalNotification(message, isCall: false);
        }
      } catch (e, st) {
        print('Error handling onMessage: $e\n$st');
      }
    });

    // When user taps notification and app opens from background
    FirebaseMessaging.onMessageOpenedApp.listen((RemoteMessage message) async {
      try {
        final data = message.data;
        print('FCM onMessageOpenedApp: ${data}');
        if (data['type'] == 'doctor_call') {
          final apptId = int.tryParse(data['appointment_id'] ?? '') ?? 0;
          final room = data['room'] ?? '';
          final doctorName = data['doctor_name'] ?? 'Doctor';
          final callLogId = data.containsKey('call_log_id') ? int.tryParse(data['call_log_id'] ?? '') : null;

          navigatorKey.currentState?.push(MaterialPageRoute(
            builder: (_) => IncomingCallPage(
              appointmentId: apptId,
              room: room,
              doctorName: doctorName,
              callLogId: callLogId,
            ),
          ));
        } else {
          await _showLocalNotification(message, isCall: false);
        }
      } catch (e) {
        print('Error in onMessageOpenedApp handler: $e');
      }
    });

    // App launched from terminated state via a notification
    try {
      final initialMessage = await FirebaseMessaging.instance.getInitialMessage();
      if (initialMessage != null && initialMessage.data['type'] == 'doctor_call') {
        final data = initialMessage.data;
        final apptId = int.tryParse(data['appointment_id'] ?? '') ?? 0;
        final room = data['room'] ?? '';
        final doctorName = data['doctor_name'] ?? 'Doctor';
        final callLogId = data.containsKey('call_log_id') ? int.tryParse(data['call_log_id'] ?? '') : null;

        WidgetsBinding.instance.addPostFrameCallback((_) {
          navigatorKey.currentState?.push(MaterialPageRoute(
            builder: (_) => IncomingCallPage(
              appointmentId: apptId,
              room: room,
              doctorName: doctorName,
              callLogId: callLogId,
            ),
          ));
        });
      }
    } catch (e) {
      print('Error handling initialMessage: $e');
    }
  } // end if patient

  if (mounted) setState(() => loading = false);
}

  /// <<RINGTONE_UNLOCK_PROMPT>>
  /// This dialog is shown to web patients once to allow autoplay (tiny unlock play).
  Future<void> _showEnableRingtoneDialog() async {
    final ctx = navigatorKey.currentContext;
    if (ctx == null) return;
    showDialog(
      context: ctx,
      barrierDismissible: false,
      builder: (ctx2) {
        return AlertDialog(
          title: const Text('Enable Ringtone'),
          content: const Text('To hear incoming call ringtone in the browser, please enable ringtone (allow audio).'),
          actions: [
            TextButton(
              onPressed: () {
                Navigator.of(ctx2).pop();
              },
              child: const Text('Later'),
            ),
            ElevatedButton(
              onPressed: () async {
                Navigator.of(ctx2).pop();
                await RingtoneService.unlockAudioOnce();
                final prefs = await SharedPreferences.getInstance();
                await prefs.setBool('ringtone_unlocked', true);
                if (mounted) setState(() {});
                showSnack(navigatorKey.currentContext!, 'Ringtone enabled');
              },
              child: const Text('Enable Ringtone'),
            ),
          ],
        );
      },
    );
  }

  @override
  Widget build(BuildContext context) {
    if (loading) return const Scaffold(body: Center(child: CircularProgressIndicator()));
    if (me == null) return const LoginPage();
    return HomeRouter(me: me!);
  }
}

/// Router that returns the correct dashboard depending on role
class HomeRouter extends StatelessWidget {
  const HomeRouter({super.key, required this.me});
  final User me;

  @override
  Widget build(BuildContext context) {
    switch (me.role) {
      case 'admin':
        return admin.AdminDashboard(me: me);
      case 'doctor':
        return doctor.DoctorDashboard(me: me);
      default:
        return patient.PatientDashboard(me: me);
    }
  }
}

/// =====================
/// LOGIN + REGISTER PAGE
/// (unchanged UI from your earlier code)
/// =====================
class LoginPage extends StatefulWidget {
  const LoginPage({super.key});
  @override
  State<LoginPage> createState() => _LoginPageState();
}

class _LoginPageState extends State<LoginPage> {
  final email = TextEditingController();
  final pass = TextEditingController();
  bool busy = false;

  void _prefill(String role) {
    if (role == 'patient') {
      email.text = 'patient1@test.com';
      pass.text = 'patientpass';
    } else if (role == 'doctor') {
      email.text = 'alice@clinic.tes';
      pass.text = 'alicepass';
    } else if (role == 'admin') {
      email.text = 'admin@example.com';
      pass.text = 'admin';
    }
  }

  Future<void> _login() async {
    setState(() => busy = true);
    try {
      await AuthService.login(email.text.trim(), pass.text);
      final me = await AuthService.whoAmI();
      if (context.mounted) {
        Navigator.of(context).pushReplacement(MaterialPageRoute(builder: (_) => HomeRouter(me: me)));
      }
    } catch (e) {
      if (context.mounted) showSnack(context, 'Login failed: $e');
    } finally {
      if (mounted) setState(() => busy = false);
    }
  }

  Future<void> _ping() async {
    try {
      final pong = await Api.get('/ping');
      if (mounted) showSnack(context, 'API OK: $pong @ ${Api.baseUrl}');
    } catch (e) {
      if (mounted) showSnack(context, 'API NOT REACHABLE @ ${Api.baseUrl}\n$e');
    }
  }

  @override
  Widget build(BuildContext context) {
    final double w = MediaQuery.of(context).size.width.clamp(320.0, 520.0).toDouble();
    return Scaffold(
      appBar: AppBar(title: const Text('Smart Gateway — Login')),
      body: Center(
        child: ConstrainedBox(
          constraints: BoxConstraints(maxWidth: w),
          child: Card(
            margin: const EdgeInsets.all(16),
            child: Padding(
              padding: const EdgeInsets.all(16),
              child: Column(mainAxisSize: MainAxisSize.min, children: [
                Text('API: ${Api.baseUrl}', style: Theme.of(context).textTheme.bodySmall),
                const SizedBox(height: 6),
                FilledButton.icon(onPressed: _ping, icon: const Icon(Icons.wifi_tethering), label: const Text('Ping API')),
                const Divider(height: 24),
                TextField(controller: email, decoration: const InputDecoration(labelText: 'Email or Phone', border: OutlineInputBorder())),
                const SizedBox(height: 12),
                TextField(controller: pass, obscureText: true, decoration: const InputDecoration(labelText: 'Password', border: OutlineInputBorder())),
                const SizedBox(height: 12),
                Row(
                  children: [
                    Expanded(child: OutlinedButton(onPressed: () => _prefill('admin'), child: const Text('Fill Admin'))),
                    const SizedBox(width: 8),
                    Expanded(child: OutlinedButton(onPressed: () => _prefill('doctor'), child: const Text('Fill Doctor'))),
                    const SizedBox(width: 8),
                    Expanded(child: OutlinedButton(onPressed: () => _prefill('patient'), child: const Text('Fill Patient'))),
                  ],
                ),
                const SizedBox(height: 12),
                FilledButton(
                  onPressed: busy ? null : _login,
                  child: busy ? const SizedBox(width: 18, height: 18, child: CircularProgressIndicator(strokeWidth: 2)) : const Text('Login'),
                ),
                const SizedBox(height: 8),
                TextButton(onPressed: () => Navigator.of(context).push(MaterialPageRoute(builder: (_) => const RegisterPage())), child: const Text('Register as Patient')),
              ]),
            ),
          ),
        ),
      ),
    );
  }
}

class RegisterPage extends StatefulWidget {
  const RegisterPage({super.key});
  @override
  State<RegisterPage> createState() => _RegisterPageState();
}

class _RegisterPageState extends State<RegisterPage> {
  final name = TextEditingController();
  final email = TextEditingController();
  final phone = TextEditingController();
  final pass = TextEditingController();
  bool busy = false;

  Future<void> _register() async {
    setState(() => busy = true);
    try {
      await AuthService.registerPatient(
        name: name.text,
        email: email.text.isEmpty ? null : email.text,
        phone: phone.text.isEmpty ? null : phone.text,
        password: pass.text,
      );
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Registered! Now login.')));
        Navigator.pop(context);
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Register failed: $e')));
      }
    } finally {
      if (mounted) setState(() => busy = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    final double w = MediaQuery.of(context).size.width.clamp(320.0, 520.0).toDouble();
    return Scaffold(
      appBar: AppBar(title: const Text('Register (Patient)')),
      body: Center(
        child: ConstrainedBox(
          constraints: BoxConstraints(maxWidth: w),
          child: Card(
            child: Padding(
              padding: const EdgeInsets.all(16),
              child: Column(mainAxisSize: MainAxisSize.min, children: [
                TextField(controller: name, decoration: const InputDecoration(labelText: 'Name', border: OutlineInputBorder())),
                const SizedBox(height: 12),
                TextField(controller: email, decoration: const InputDecoration(labelText: 'Email (optional)', border: OutlineInputBorder())),
                const SizedBox(height: 12),
                TextField(controller: phone, decoration: const InputDecoration(labelText: 'Phone (optional)', border: OutlineInputBorder())),
                const SizedBox(height: 12),
                TextField(controller: pass, obscureText: true, decoration: const InputDecoration(labelText: 'Password', border: OutlineInputBorder())),
                const SizedBox(height: 12),
                FilledButton(onPressed: busy ? null : _register, child: busy ? const SizedBox(width: 18, height: 18, child: CircularProgressIndicator(strokeWidth: 2)) : const Text('Create account')),
              ]),
            ),
          ),
        ),
      ),
    );
  }
}

/// Minimal AppointmentDetailPage used for notification navigation.
/// Replace with your own detailed page if you already have it.
class AppointmentDetailPage extends StatefulWidget {
  final int apptId;
  const AppointmentDetailPage({super.key, required this.apptId});
  @override
  State<AppointmentDetailPage> createState() => _AppointmentDetailPageState();
}

class _AppointmentDetailPageState extends State<AppointmentDetailPage> {
  Map<String, dynamic>? appt;
  bool loading = true;
  String err = '';

  @override
  void initState() {
    super.initState();
    _load();
  }

  Future<void> _load() async {
    setState(() => loading = true);
    try {
      final res = await Api.get('/appointments/${widget.apptId}');
      appt = (res is Map) ? Map<String, dynamic>.from(res as Map) : null;
      err = '';
    } catch (e) {
      err = 'Load failed: $e';
    } finally {
      if (mounted) setState(() => loading = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    if (loading) return const Scaffold(body: Center(child: CircularProgressIndicator()));
    if (err.isNotEmpty) return Scaffold(appBar: AppBar(title: const Text('Appointment')), body: Center(child: Text(err)));
    final d = appt ?? {};
    final doctor = (d['doctor'] is Map) ? d['doctor'] : null;
    final doctorName = doctor != null ? (doctor['name'] ?? '') : (d['doctor_name'] ?? '');
    final time = d['time'] ?? d['slot'] ?? '—';
    final status = d['progress'] ?? d['status'] ?? '—';

    return Scaffold(
      appBar: AppBar(title: const Text('Appointment')),
      body: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(crossAxisAlignment: CrossAxisAlignment.start, children: [
          Text('Appointment ID: ${d['id'] ?? widget.apptId}', style: const TextStyle(fontWeight: FontWeight.w600)),
          const SizedBox(height: 8),
          Text('Doctor: $doctorName'),
          const SizedBox(height: 8),
          Text('Time: $time'),
          const SizedBox(height: 8),
          Text('Status: $status'),
          const SizedBox(height: 20),
          ElevatedButton(
            onPressed: () {
              showSnack(context, 'Join video not implemented in this minimal detail page');
            },
            child: const Text('Join Video'),
          ),
        ]),
      ),
    );
  }
}
